---
title: "Internet Computer Execution Layer"
abstract: 
shareImage: /img/how-it-works/network-nervous-system-nns.600.jpg
slug: execution-layer
---

# Execution
The execution layer is the topmost layer of the IC core protocol stack and is responsible for executing the messages that reach the canisters.  Recall that a canister smart contract on the IC bundles together code (in the form of a Wasm module), and state (a set of memory pages that the code can access).  When installed on the IC, the content of a canister is replicated across all of the nodes that comprise one of the subnetworks of the IC.
Each node in the subnet holding the same canister state and ensuring that the state transitions in the same way on every node in every round is the foundation of realising a deterministic replicated state machine and the security and resilience properties thereof that make blockchains so unique.
## Replicated Message Execution
Execution proceeds in rounds. In every round, the message routing layer gets a block of messages from consensus, it puts these messages into the input queues of their destination canisters and then hands over control to the execution layer.  This layer determines an order in which to execute the canisters and then schedules either until all messages in the canisters' queues are consumed or the instruction limit for the round has been reached.  The bound on the total number of instructions that can be executed in a round guarantees that each round finishes in a bounded amount of time.
Canister execution can span multiple rounds through a novel technique called *deterministic time slicing (DTS*). That is, execution of canisters which requires more instructions than available in a round is paused and continues in the subsequent round.
Each message execution can lead to memory pages of the canister's state being modified (becoming "dirty" in operating systems terminology), new messages (or responses to messages) to other canisters on the same or different subnets being created, or responses to be generated for ingress messages of users.
When a message execution leads to the generation of a new canister message targeted at a canister in the local subnet, this message can be queued up directly by execution in the input queue of the target canister and scheduled in the same round or an upcoming round, without this new message needing to go through consensus. This is possible because the generation and enqueuing of the new message is completely deterministic and thus happens in exactly the same way on all the nodes of the subnet – thus there is no need for this new message going through consensus.
New messages targeted at other subnets are placed into the target cross-subnet queue (XNet queue) and are certified by the subnet at the end of the round as part of the per-round state certification. The receiving subnet can verify that the XNet messages are authenticated by the originating subnet by validating the signature with the originating subnet's public key.
The execution layer is designed at its core to execute multiple canisters concurrently on different CPU cores. This is possible because each canister has its own isolated state and canister communication is asynchronous. This form of concurrent execution within a subnet together with the capability of all of the IC's subnets executing canisters concurrently makes the IC scalable like the public cloud: The IC scales out by adding more subnets.
## Non-replicated message Execution
Non-replicated message execution, aka query calls,  are operations that are executed by a single node and return a response synchronously, much like a regular function invocation in an imperative programming language. The key difference to replicated message execution, also called *update calls*, is that queries cannot change the replicated state of the subnet, while update calls can. Queries are, as the name suggests, essentially read operations performed on one replica of the subnet, with the associated trust model of a compromised replica being able to return any arbitrary result of its choice.
Queries are executed concurrently by multiple threads on a node. As queries are executed in a non-replicated way, all the nodes in a subnet can concurrently execute different queries. Query throughput of a subnet thus increases linearly with an increasing number of nodes in the subnet.
Queries are similar to read operations on a local or cloud Ethereum node on the Ethereum blockchain. A decentralized application (dApp) should use queries for non-critical operations only. Whenever an information item to be read is critical, e.g., financial data based on which decisions are made, update calls should be used to obtain such information as the response of an update call is certified by the subnet with a BLS threshold signature and verifiable with the subnet's public key.
## Memory Handling
Management of the canister bytecode and state is one of the key responsibilities of the execution layer. The replicated state that can be held by a single subnet is not bounded by the available RAM in the node machines, but rather by the available SSD storage. Available RAM, however, impacts the performance of the subnet, particularly the access latency of memory pages. This depends a lot on the access patterns of the workload – much like in traditional computer systems.
The IC’s node machines are equipped with terabytes of high-end SSD storage and over half a terabyte of RAM to be able to hold large amounts of replicated canister state and Wasm code and achieve good performance when accessing memory. While the execution layer maintains the memory data structures and updates them accordingly to reflect modifications to memory pages, the state management component of message routing is responsible for certifying (parts of) the state through the subnet at the end of a round or once every (much longer) checkpointing interval.
Memory pages representing canister state are persisted to SSD by the execution layer, without canister programmers needing to take care of this. Having all memory pages transparently persisted enables orthogonal persistence and frees the smart contract programmers from reading from and writing to storage as on other blockchains or as in traditional IT systems. This dramatically simplifies smart contract implementation and helps reduce the TCO of a dApp and thus reduce its time to market. Programmers can always have the full canister smart contract state on the heap or in stable memory.
By default, however, canisters are mutable so their code can be updated to fix bugs or update the business logic.  Updates clear the heap of a canister.  To ensure that heap content is not lost on upgrade, canisters can transfer heap content to stable memory, a piece of memory which is preserved between upgrades.  Best practices are that large canister state be held directly in stable memory to avoid shuffling around large amounts of storage before and after each upgrade. This also avoids the risk of exceeding the cycle limit allowed in an upgrade operation and extends orthogonal persistence even across upgrades.
## Cycles Accounting
The execution of a canister consumes resources of the Internet Computer, which are paid for with cycles that the canister must have been topped up with. Filling up the canister with cycles is the responsibility of its maintainer, which can be a developer, a group of developers or a decentralised autonomous organisation (DAO) – users do not pay for sending messages to canisters on the IC. This resource charging model is known as reverse gas model and is a facilitator for mass adoption of the IC.
Technically, the Wasm code running in a canister gets instrumented, when the Wasm bytecode is installed or updated on the IC, with code that counts the executed instructions for smart contract messages. This allows for deterministically determining the exact amount of cycles to be charged for a given message being executed. Using Wasm as bytecode format for canisters has helped greatly to reach overall determinism because Wasm itself is a format that is largely deterministic in its execution. It is crucial that the cycles charging be completely deterministic so that every node computes exactly the same amount of cycles to be charged for a given operation and thus that the replicated state machine properties of the subnet are maintained.
The memory the canister uses in terms of both its Wasm code and canister state needs to be paid for with cycles as well. Much like in the public cloud, consumed storage is charged per time unit. Compared to other blockchains, it is very inexpensive to store data on the IC. Furthermore, networking activities such as receiving ingress messages, sending XNet messages, and making HTTPS Outcalls to Web 2.0 servers are paid for in cycles by the canister.
Pricing for a resource on the IC is extremely competitive. Prices for a given resource, e.g., executing Wasm instructions, scale with the replication factor of the subnet, i.e., the number of nodes that power the subnet, once subnets of different replication factor will become available.
## Random Number Generation
Many applications benefit from, or require a secure random number generator.  Yet, generating random numbers in the naïve way as part of execution trivially destroys determinism as every node would compute different randomness.
The IC solves this problem by the execution layer having access to a decentralised pseudorandom number generator called the *random tape*. The random tape is built using [chain-key cryptography](https://internetcomputer.org/how-it-works/#Chain-key-cryptography). Every round, the subnetwork produces a fresh BLS signature which, by its very nature, is unpredictable and uniformly distributed.  This signature can then be used as seed in a cryptographic pseudorandom generator.  This gives canister smart contracts access to a highly-efficient and secure random number source, which is another unique feature of the Internet Computer. 

